main
- init variables -> count no of env -> calloc ms_env -> copy env to ms_env -> assign key "OLDPWD" if non-existent in env
- ms_env to variables -> combine key and value & store into variables
- set SHLVL -> if exists in ms_env -> update value -> else add to ms_env
- save term settings
- do loop

do loop
- init signals -> C > new prompt; Q > SIG_IGN
- get input -> set term settings -> rl_replace_line -> readline -> restore term settings -> trim whitespace form input -> add history -> if !input, exit
- process input -> go through lexer, expander, parser -> return error no -> clean lexer

lexer
- spaces -> tokenize spaces
- print syntax error when disallowed char
- tokenize (< << > >> | $ ' " words) -> add to tokenlist

dollars $
- if next char is '\0' or space -> treat as word token
- if next char is digit -> i++
- if next char is '?' -> exitcode token

quotes ' "
- if " -> expand " -> extract words and tokenize it 
	-> if $
	-> if next char '\0' or space -> treat as word token
	-> if next char digit -> i++
	-> if next char '?' -> exitcode token
	-> add dollar and word tokens
- if ' -> tokenize '

expander
- remove dup tokens -> if prev exists -> cut token else cut head token
- quotes to words -> change token type from quotes to words
- expand dollars -> search list for $ and words token -> cut token
				 -> if '?' -> exitcode
				 -> if disallowed char -> insert full string
				 -> if get value from env -> insert token (& remove current token)
				 -> else expand dollar tailbit -> if data > key -> extract tail part -> else remove token cos no value from env
- word join -> if current and next token type is words, join them
- remove space tokens -> cut tokens

parser
- check pipe syntax -> return error if pipe is first/last and double pipe
- check redir syntax 
	-> if pipe, skip 
	-> if < > << >>, and if last or next is not words, return error
- create root node for PIPE and NOPIPE -> put at the end of other root nodes
- create node for redir < > << >> -> put at the end of other leaf nodes
- check for word tokens -> turn all into cmd -> put at the end of other leaf nodes
- if next branch with PIPE exists -> continue loop

continue do loop
- if error -> clean tree & clean lexer -> continue loop
			-> if MALLOC FAIL -> exit (-1)
- ignore signals C & Q
- start tree

start tree
- init executor -> index & builtin check -> if error, return
- loc tree ptr ?? (might be no use)
- handle tree -> if i = 33 or 34, exitcode = 1
- unlink ".heredoc"
- clean tree & free executor

handle tree
- init exitcode
- if NOPIPE & executor index = 0 -> start nopipe
								 -> wait on children -> exitcode
								 -> return
- handle loop -> if i = 33 or 34, return (i)
- handle loop two -> if i = 33 or 34, return (i)
- copy fd of executor
- traverse next node of tree -> next root node or leaf node
- wait on children -> exitcode
- close all executor fd (in and out)

nopipe start
- executor index +1
- fork -> if pid < 0 -> executor error
- if pid = 0 -> restore signals
			 -> traverse down leaf nodes -> redirs loop
			 -> if type is CMD -> start nopipe helper
- check nonwritable -> search for CMD -> start builtin (export, cd, unset, exit)
									  -> return if no data in CMD

wait on children
- while executor index-- > 0 -> wait(&status) -> if WIFSIGNALED
											  -> restore term settings
											  -> process signal C & Q (WTERMSIG)
											  -> signal found = 1
- if signal found or builtin check = 1 -> return exitcode
									   -> else return WEXITSTATUS

handle loop
- if NOPIPE & executor index > 0 -> end nopipe -> if i = 33 -> handle heredoc, return (i)
- if PIPE & executor index > 0 -> pipe inbetween -> if i = 33 -> handle heredoc, return (i)
												 -> if i = 666, return (i)

handle loop two
- if PIPE & executor index = 0 -> start pipe -> if i = 33 -> handle heredoc, return (i)
											 -> if i = 34, return (i)

redirs loop
- if REDIR IN -> open fd in -> access F_OK -> access R_OK -> else redir error
			  -> dup2 -> close
- if REDIR OUT -> open fd out -> access W_OK -> else redir error
			   -> dup2 -> close
- redirs loop two

redirs loop two
- if APPEND -> open fd out -> access W_OK -> else redir error
			-> dup2 -> close
- if HEREDOC & leaf node not HEREDOC -> restore term settings
									 -> set term settings
									 -> init heredoc signals
									 -> if PIPE & heredoc dont exists up node -> close
									 -> make heredoc fd in
									 -> dup2 -> close -> unlink ".heredoc"

nopipe end
- executor index +1
- copy fd
- if heredoc exists up node -> wait
- fork
- if pid < 0 -> executor error
- if pid = 0 -> nopipe child
- if nopipe end util = 33 -> return 33
- close fd in

nopipe child
- while leaf node -> redirs loop
- if CMD -> nopipe end helper

nopipe end helper
- if no data -> close fd in -> close fd out -> free envi -> exit
- dup2 -> close fd in -> close fd out -> check builtin child -> get paths

nopipe end util
- if leaf node & HEREDOC -> waitpid -> if WIFSIGNALED, return 33

start pipe
- executor index +1
- if pipe fd out < 0 -> executor error
- fork
- if pid < 0 -> executor error
- if pid = 0 -> restore signals -> helper start pipe
- start pipe util
- if i = 34, return 34

start pipe helper
- while leaf node -> redirs loop
- if CMD -> if no data -> close fd in -> close fd out -> free envi -> exit
		 -> dup2 -> close fd out -> check builtin child -> get paths
- close fd in -> close fd out

pipe start util
- if leaf node & HEREDOC -> waitpid -> if WIFSIGNALED & WTERMSIG not = 81, return 34

pipe inbetween
- executor index +1
- if pipe fd out < 0 -> executor error
- if heredoc exists up node -> wait
- fork
- if pid < 0 -> executor error
- if pid = 0 -> helper pipe inbetween
- if leaf node & type is HEREDOC -> waitpid -> if WIFSIGNALED, return 33
- close fd

helper pipe inbetween
- while leaf node -> redirs loop
- if type is CMD -> if no data -> close fd in -> close fd out -> free envi -> exit
				 -> if fd in -> dup2
				 -> dup2 -> close fd in -> close fd out -> check builtin child -> get paths

check builtin child
- if echo -> builtin echo
- if cd -> ms cd -> exitcode -> i++
- check builtin add
- if exit -> exit -> exitcode -> i++
- if i not 0 -> free envi -> exit -> else return (i)

check builtin add
- if pwd -> pwd builtin
- if export -> ms export -> exitcode -> i++
- if unset -> ms unset -> exitcode -> i++
- if env -> ms env -> exitcode -> i++

get paths
- find path env -> split -> free ; else executor error
- access and execute
